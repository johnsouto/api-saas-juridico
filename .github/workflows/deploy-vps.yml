name: Deploy (VPS)

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

concurrency:
  group: deploy-vps-production
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy to VPS via SSH
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Configure SSH
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          VPS_SSH_KEY_B64: ${{ secrets.VPS_SSH_KEY_B64 }}
        run: |
          set -euo pipefail
          if [ -z "${VPS_HOST:-}" ] || [ -z "${VPS_USER:-}" ] || [ -z "${VPS_PATH:-}" ]; then
            echo "Missing required secrets. Please set: VPS_HOST, VPS_USER, VPS_PATH"
            exit 1
          fi
          if [ -z "${VPS_SSH_KEY_B64:-}" ] && [ -z "${VPS_SSH_KEY:-}" ]; then
            echo "Missing required secret. Please set one of: VPS_SSH_KEY_B64 (recommended) or VPS_SSH_KEY"
            exit 1
          fi

          mkdir -p ~/.ssh
          if [ -n "${VPS_SSH_KEY_B64:-}" ]; then
            # Recommended: store the SSH key as a single-line base64 secret to avoid newline issues.
            # We also strip whitespace because some copy/paste flows introduce spaces/newlines.
            CLEAN_B64="$(printf "%s" "$VPS_SSH_KEY_B64" | tr -d ' \n\t\r')"
            if ! printf "%s" "$CLEAN_B64" | base64 -d > ~/.ssh/id_ed25519; then
              echo "Warning: VPS_SSH_KEY_B64 is invalid base64. Falling back to VPS_SSH_KEY."
              if [ -z "${VPS_SSH_KEY:-}" ]; then
                echo "VPS_SSH_KEY is missing; cannot continue."
                exit 1
              fi
              printf "%s\n" "$VPS_SSH_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
            fi
          else
            # Fallback: multiline key (can be fragile depending on copy/paste).
            printf "%s\n" "$VPS_SSH_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
          fi
          chmod 600 ~/.ssh/id_ed25519

          echo "Validating SSH private key format..."
          # Validate the key format early to avoid a confusing ssh exit code 255 later.
          # Never print the key contents in logs.
          if ! ssh-keygen -y -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "SSH key validation failed. Please re-check the VPS_SSH_KEY secret (must be an OpenSSH private key)."
            exit 1
          fi

          # Add VPS host key (simple approach).
          # If you want stricter security, replace this with a pinned known_hosts entry.
          echo "Fetching VPS host key via ssh-keyscan..."
          for i in {1..5}; do
            if ssh-keyscan -T 10 -H "$VPS_HOST" >> ~/.ssh/known_hosts; then
              break
            fi
            echo "ssh-keyscan failed (attempt ${i}/5). Retrying..."
            sleep 2
          done

          # Ensure we actually recorded a host key; otherwise SSH will fail with StrictHostKeyChecking=yes.
          if ! ssh-keygen -F "$VPS_HOST" >/dev/null 2>&1; then
            echo "Failed to add VPS host key to known_hosts. Check that port 22 is reachable from GitHub Actions."
            exit 1
          fi

      - name: Deploy
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
        run: |
          set -euo pipefail

          # Note: this deploy job does not need to checkout the repository locally.
          # We deploy by SSH and pull the repository on the VPS itself.
          ssh -o BatchMode=yes -o ConnectTimeout=15 -o StrictHostKeyChecking=yes "${VPS_USER}@${VPS_HOST}" "set -euo pipefail; \
            cd '${VPS_PATH}'; \
            echo '--- git pull (with retries) ---'; \
            for i in 1 2 3; do \
              if git pull --ff-only; then break; fi; \
              echo \"git pull failed (attempt \${i}/3). Retrying in 10s...\"; \
              sleep 10; \
            done; \
            # Final attempt (will fail the deploy if it still can't pull).
            git pull --ff-only; \
            echo '--- docker compose up ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build traefik api web; \
            echo '--- docker compose ps ---'; \
            docker compose ps"

      - name: Health check (API)
        id: health
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail

          URL="https://elementojuris.cloud/api/health"
          echo "Health check: ${URL}"

          # TLS cert issuance (Let's Encrypt) can take a bit on first deploy.
          # We wait up to ~2 minutes to reduce false negatives.
          for i in {1..60}; do
            if BODY="$(curl -fsS --max-time 10 "${URL}")"; then
              echo "Response: ${BODY}"
              if echo "${BODY}" | grep -q '"status"' && echo "${BODY}" | grep -q 'ok'; then
                echo "API is healthy."
                exit 0
              fi
            fi

            echo "Waiting for API... attempt ${i}/60"
            sleep 2
          done

          echo "Health check failed."
          curl -vk --max-time 10 "${URL}" || true
          exit 1

      - name: Collect VPS logs (only if health check failed)
        if: steps.health.outcome == 'failure'
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
        run: |
          set -euo pipefail

          echo "Collecting docker compose logs from VPS..."

          ssh -o BatchMode=yes -o ConnectTimeout=15 -o StrictHostKeyChecking=yes "${VPS_USER}@${VPS_HOST}" "set -euo pipefail; \
            cd '${VPS_PATH}'; \
            echo '--- docker compose ps ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml ps || true; \
            echo '--- traefik logs (tail=200) ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=200 traefik || true; \
            echo '--- api logs (tail=200) ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=200 api || true; \
            echo '--- web logs (tail=200) ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=200 web || true; \
            echo '--- postgres logs (tail=200) ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=200 postgres || true; \
            echo '--- minio logs (tail=200) ---'; \
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=200 minio || true"

      - name: Fail deploy if API is unhealthy
        if: steps.health.outcome == 'failure'
        shell: bash
        run: exit 1
